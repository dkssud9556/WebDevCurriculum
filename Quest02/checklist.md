# Check-List

## CSS를 HTML에 적용하는 세 가지 방법은 무엇일까요?

- Inline Style Sheet : HTML 태그의 style 속성에 CSS 코드를 넣는 방식
  - 장점 : CSS를 직관적으로 적용할 수 있다.
  - 단점 : 유지보수하기 어려우며, 비슷한 요소들의 스타일을 한 번에 변경할 때 일괄변경하기 어렵다.
- Internal Style Sheet : HTML 문서의 `<style>` 태그 안에 CSS 코드를 넣는 방식
  - 장점 : 여러 요소들에 한꺼번에 스타일을 적용할 수 있다.
  - 단점 : 해당 HTML 문서에만 스타일을 적용할 수 있다.
- Linking Style Sheet : 별도의 CSS 파일을 만들고 `<link>` 태그를 통해 HTML 문서와 연결하는 방식
  - 장점 : 여러 HTML 문서에서 재활용할 수 있다. 유지보수에 용이하며, 가장 안정적이다.
  - 단점 : CSS 파일의 복잡성을 관리해주어야 한다.

## CSS 규칙의 우선순위는 어떻게 결정될까요?

1. 우선순위
   1. `!important`가 붙은 속성
   2. Inline 방식으로 적용한 속성
   3. `#id`로 적용한 속성
   4. `.클래스`, `:추상클래스`로 적용한 속성
   5. `태그이름`으로 적용한 속성
   6. 상위 객체에 의해 상속된 속성
2. 만약 선택자가 같을 경우 뒤에 나오는 CSS가 우선된다.
3. 만약 우선순위가 같을 시 다음의 특정도 계산식을 토대로 가장 높은 점수를 얻은 것이 우선된다.
   - 인라인 스타일 1000점
   - ID 선택자 100점
   - 클래스 선택자 및 추상클래스(:before, :hover 등), 속성 10점
   - 태그 선택자 1점

## CSS의 박스모델은 무엇일까요? 박스가 화면에서 차지하는 크기는 어떻게 결정될까요?

- 박스모델 : 모든 HTML 요소가 가지고 있는 박스 형태의 영역.
  - 브라우저가 랜더링할 때 박스 모델의 크기와 프로퍼티, 위치를 근거로 한다.

- 박스의 구성
  - Content : 요소의 텍스트, 이미지 등 실제 내용이 들어가는 공간. width, height 프로퍼티를 갖는다.
  - Padding : Border 안쪽에 위치하는 요소의 내부 여백 공간. 기본색은 투명이며, 요소에 적용된 배경색과 이미지는 Padding 영역까지 적용된다.
  - Border : 테두리 영역.
  - Margin : Border 바깥에 위치하는 요소의 외부 여백 공간. 기본색은 투명이며, 배경색 지정이 불가하다.
- 박스가 화면에서 차지하는 크기는 Content의 width, height 프로퍼티, Padding 영역의 두께, Border의 두께, Margin 영역의 두께를 종합하여 결정된다.

## `float` 속성은 왜 좋지 않을까요?

- `float` 속성

  - 레이아웃 속성을 사용하지 않았을 때 웹 페이지 요소는 작성한 HTML 코드 순서대로(좌->우, 상->하) 배치되었고, 이를 `Normal flow` 레이아웃 기법이라고 한다. `Normal flow` 레이아웃 기법으로 이미지와 텍스트가 같이 어울리는 레이아웃을 표현할 수 없었기 때문에 나온 것이 `float` 속성이다. `float` 속성이 붙으면 해당 요소는 `Normal flow`에서 제외되며 붕뜨게 된다.

  - `float` 속성은 Flexbox와 Grid가 나오기 이전까지 원래의 의도가 아닌 웹 페이지의 레이아웃을 잡는 용도로 많이 사용되었다.

  - `float` 속성은 Flexbox와 Grid가 나오기 이전까지 원래의 의도가 아닌 웹 페이지의 레이아웃을 잡는 용도로 많이 사용되었다.

  - 단점

    1. `float` 속성을 적용한 요소를 감싸는 부모 요소에 height값이 지정되어 있지 않으면 `float` 속성을 적용한 요소는 부모 요소에게 인식되지 않아서 부모 요소의 height 값이 0이 된다. 즉, 다음 요소의 레이아웃 배치에 영향을 줄 수 있다.

    2. `float`를 적용할 요소들의 height가 제각각이면 예상하던 결과를 기대하기 어렵다.

    3. `float` 속성은 다음 요소로 속성이 상속된다. 적절한 위치에서 `clear` 속성을 사용하지 않으면 원하는 결과를 얻을 수 없다.

## Flexbox(Flexible box)와 CSS Grid의 차이와 장단점은 무엇일까요?

- Flexbox
  - 1차원적으로 레이아웃을 설정할 수 있다. 레이아웃을 수평이나 수직 방향 둘 중 하나만 설정할 수 있다는 뜻이다.
  - 장점
    - float 속성을 이용한 레이아웃 방식에 비해 쉽고, 수평과 수직 모든 방향의 정렬을 간단하게 수행할 수 있다.
  - 단점
    - 최근에 나온 속성이기 때문에 과거 버전의 브라우저에서는 동작하지 않을 수 있다.
- Grid
  - 2차원적으로 레이아웃을 설정할 수 있다. 레이아웃을 수평과 수직 방향을 동시에 설정할 수 있다는 뜻이다.
  - 장점
    - Flexbox는 어느 한 부분의 간단한 레이아웃을 처리한다면, Grid는 큰 범위의 레이아웃을 설정할 수 있다.
  - 단점
    - Flexbox보다 동작하지 않는 브라우저가 많다.

## CSS의 비슷한 요소들을 어떤 식으로 정리할 수 있을까요?

# Advanced

## 왜 CSS는 어려울까요?

CSS 코드를 짜다보면 어쩔 수 없이 태그들간의 의존이 생긴다. 심지어 CSS 속성 중에서 부모에서 자식으로 상속되는 속성들도 있기 때문에 이 또한 생각을 해야 한다. 그래서 변경을 하기 위해서 이러한 의존들을 신경써가며 변경을 해야 한다. 그냥 막 변경하면 CSS가 완전히 무너질 수도 있다.

또한 CSS는 런타임에 따라서 보이는 모습이 달라지기 때문에 이를 예측하기도 쉽지 않다.

## CSS의 어려움을 극복하기 위해 어떤 방법들이 제시되고 나왔을까요?

- SASS
  - 개요 : SASS는 CSS Pre-processor이다. 즉, CSS를 프로그래밍적으로 작성하고, 이를 컴파일하여 CSS 파일로 만드는 것이다.
  - 특징
    - 변수를 사용할 수 있으며, 조건문과 반복문도 사용할 수 있다.
    - import를 통해서 작게 쪼개서 합칠 수 있다.
    - Nesting을 통해 중복없이 HTML 구조 그대로 CSS를 만들 수 있다.
- BEM (Block Element Modifier)
  - 개요 : CSS 구조를 개선시키기 위한 CSS 개발 방법론.
  - 문제의 요소에 대한 속성에 근거하는 클래스의 이름을 짓는데 구조적인 방법을 제시한다.
  - 구성요소
    - Blcok : 문단 전체에 적용된 요소 또는 요소를 담고 있는 컨테이너. Block은 클래스 명의 어근을 형성하며, 항상 맨 앞에 붙는다.
    - Element : Block이 포함하고 있는 한 조각. 각 Element는 두 개의 밑줄표시로 연결하여 블럭 다음에 위치시킨다.
    - Modifier : Block 또는 Element의 속성. 이 속성은 Block 또는 Element의 외관 또는 상태를 변경시킨다.
  - 형태 : Block__Element--Modifier
- CSS Modules
  - SASS와 BEM 방법론은 개발자가 손수 클래스가 겹치지 않도록 노력해야 했다. 이러한 점을 보완하기 위해 나온 것이 CSS Modules이다.
  - 모든 스타일에 CSS 선택자에 고유한 해시 문자열을 추가하여 CSS 속성이 겹치지 않도록 한다.
  - 파일이름.module.css 형식으로 파일을 만들어서 import를 통해 css를 불러올 수 있다.
- CSS in JS
  - 개요 : 이름 그대로 JS 코드에서 CSS를 작성하는 것이다.
  - className은 내부적으로 임의의 해시 값을 생성하여 지정하기 때문에 개발자는 className에 대해서 생각할 필요가 없게 된다.
  - Styled-Components, Emotion과 같은 라이브러리가 CSS in JS를 구현한 라이브러리들이다.

## CSS가 브라우저에 의해 해석되고 적용되기까지 내부적으로 어떤 과정을 거칠까요?

1. 브라우저 렌더러 프로세스의 메인 스레드가 네트워크를 통해 HTML 텍스트를 전송받는다.
2. 메인 스레드는 HTML 텍스트를 DOM으로 파싱한다.
3. 파싱하면서 이미지나 CSS 파일과 같은 서브 리소스를 발견하면 네트워크 스레드에게 요청을 보낸다.
4. CSS 파일을 받으면 CSS 파일을 파싱하여 각 DOM 노드에 계산된 스타일을 확정시킨다.
5. DOM 노드와 계산된 스타일을 순회하면서 레이아웃 트리를 만든다. 레이아웃 트리는 xy 좌표, 박스 모델의 크기 등의 정보를 가지고 있다.
6. 레이아웃 트리를 이용하여 페인트 기록을 생성한다. 페인트 기록은 화면을 그리는 순서를 기록한 것이다.
7. DOM, 레이아웃 트리, 페인트 기록을 이용하여 화면에 픽셀로 그린다.

## 웹 폰트의 경우에는 브라우저 엔진 별로 어떤 과정을 통해 렌더링 될까요?


# Check-List

## RDBMS 테이블의 정규화는 무엇인가요?

테이블에 존재하는 이상현상(anomaly)을 제거하는 작업

- 이상현상

  1. 삽입이상 : 자료를 삽입할 때 의도하지 않은 데이터까지 삽입해야만 자료를 테이블에 추가 가능한 현상

  2. 갱신이상 : 중복 튜플 중 일부만 수정되어 데이터의 모순이 생기는 현상

  3. 삭제이상 : 튜플을 삭제할 때 필요한 데이터도 함께 삭제되는 현상

- 정규화 단계

  - 1차 정규화
    - 모든 column의 domain이 원자값이어야 한다.
    - row를 유일하게 식별하는 기본키가 있어야 한다.
    - repeating groups가 있으면 안 된다.
  - 2차 정규화
    - 모든 column들이 기본키에 완전 함수 종속해야 한다.
    - 기본키가 단일 column으로 이루어져 있으면 2차 정규화를 무조건 만족한다.
  - 3차 정규화
    - 이행 함수 종속을 제거해야 한다.
  - 보이스 코드 정규화
    - 3차 정규형을 만족하는 릴레이션에서 후보키가 여러 개일때 하나의 기본키가 정해지고, 남은 column 중에서 결정자가 존재하면 보이스 코드 정규화를 위반하는 것이다.

## MySQL 외의 RDB에는 어떤 것들이 있나요?

PostgreSQL, Oracle, Microsoft SQL Server, MariaDB 등

### Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?

- Document Database : XML, JSON과 같은 Document를 이용해 데이터를 저장하는 데이터베이스. 테이블의 스키마가 유동적이다.
  - MongoDB, Azure Cosmos DB, CouchDB, MarkLogic, OrientDB 등
- Key Value Database : 간단한 Key Value 묶음으로 데이터를 저장하는 데이터베이스. 구조가 단순하기 때문에 속도가 빠르다.
  - Redis, Oracle NoSQL Database, Voldmorte, Oracle Berkeley DB, Memcached, Hazelcast 등
- Wide Column Database : 행마다 다른 값, 다른 수의 스키마를 가질 수 있는 데이터베이스. 확장성이 좋고 쿼리 속도가 빠르다.
  - Cassandra, HBase, Google BigTable, Vertica, Druid, Accumulo, HyperTable 등
- Graph Database : 데이터를 노드로 표현하고, 간선을 통해 데이터 간의 관계를 표현하는 데이터베이스. RDBMS보다 퍼포먼스가 좋고 유연하며 유지보수에 용이하다.
  - Neo4j, Blazegraph, OrientDB , AgensGraph 등

## RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

RDBMS의 인덱싱은 특정 칼럼 또는 칼럼의 집합을 정렬하여 B Tree에 저장하고, 이를 이용하여 데이터 스캔 속도를 높이는 것이다.

인덱싱을 하면 많은 데이터 중에서 소량의 데이터를 가져와야 할 때 필요한 블록 IO를 줄일 수 있다. 또한 특정 column을 인덱싱하여 의도적으로 데이터베이스 엔진의 정렬 작업을 생략할 수 있다.

B Tree를 이용하여 수직적 탐색을 진행해서 데이터 스캔을 시작해야 하는 지점을 찾아내고, 스캔 조건이 맞지 않는 부분까지 수평적 탐색을 한다. B Tree의 리프 노드들은 서로 이어져 있기 때문에 수평적 탐색이 가능하다.

## ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?

- 장점
  - 간단한 CRUD를 위해 긴 SQL 문을 작성할 필요가 없어진다.
  - 재사용과 유지보수가 용이해진다.
  - DBMS에 대한 종속성이 줄어든다.
  - 관계형 모델과 객체지향 모델을 매핑해주기 때문에 패러다임 불일치 문제를 해결해주고, 개발자가 객체지향과 비즈니스 로직에 더 신경쓸 수 있도록 해준다.
- 단점
  - 복잡한 쿼리문 같은 경우에는 SQL문을 작성하는 것이 더 직관적이고 효율적일 때가 있다.
  - 별도의 튜닝이 필요한 SQL은 직접 작성해야 할 수도 있다.

### 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?

Sequelize, TypeORM, Prisma, Bookshelf.js 등

## 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?

- `1:1` : 하나의 모델과 하나의 모델이 맺는 관계.
  - 에시 : 나라와 대통령. 부부.
- `1:N` : 하나의 모델과 여러 개의 모델이 맺는 관계.
  - 예시 : 학교의 반과 학생. 팀과 선수. 회사와 직원.
- `N:M` : 여러 개의 모델과 여러 개의 모델이 맺는 관계.
  - 예시 : 학원과 학생. 영화와 배우. 인스타그램 팔로우.

## DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

- 해시 함수 : 임의의 길이 데이터를 입력받아서 고정된 길이의 비트열로 반환하는 함수. 동일한 입력값에는 동일한 출력값을 반환한다.

사용자의 평문 암호를 해시 함수를 통해 해싱하여 데이터베이스에 저장하고, 인증 요청이 왔을 때 평문 비밀번호를 해싱하여 데이터베이스에 저장된 암호와 비교하기 때문에 평문으로 저장하지 않아도 인증이 가능하다.

### 해시 함수에는 어떤 것이 있나요?

MD5, SHA 등

### 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?

사용자의 암호를 해싱할 때마다 랜덤한 salt를 생성하여 암호와 합쳐서 해싱해야 한다. 암호를 그대로 해싱하면 같은 입력값에는 같은 출력값을 반환하는 해시 함수의 특성으로 인해서 비밀번호를 쉽게 유추해낼 수 있다. (레인보우 테이블)

# Advanced

## Object-relational impedance mismatch란 어떤 개념인가요?

## Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?

## 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
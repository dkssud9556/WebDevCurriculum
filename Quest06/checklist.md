# Check-List

## 인터넷은 어떻게 동작하나요? Internet Protocol Suite의 레이어 모델에 입각하여 설명해 보세요.

### 근거리에서 서로 떨어진 두 전자기기가 유선/무선으로 서로 통신하는 프로토콜은 어떻게 동작할까요?

- 이더넷 (유선)
  - 전자기기의 MAC 주소를 이용해서 통신하는 프로토콜이다.
  - 중간에 LAN 장비(2계층 장비)를 통해서 통신을 한다.
  - 보내고자 하는 전자기기의 MAC 주소와 자신의 MAC 주소를 담은 프레임을 전송한다.
  - 중간 장비는 MAC 주소 테이블을 확인하여 목적지 MAC 주소 정보가 있으면 해당 목적지로 포워딩을 하게 되고, 만약 없으면 수신받은 포트를 제외한 모든 곳으로 프레임을 Flooding한다.
- IEEE 802.11 (무선)
  - 무선 LAN 구성
    - 무선 LAN 인터페이스 : 대부분의 단말에 내장되어 있다.
    - 무선 LAN 액세스 포인트 : 무선 LAN 데이터 통신을 위한 액세스 포인트
      - 보통의 서버들은 유선 이더넷으로 접속되기 때문에 무선 LAN 액세스 포인트도 유선 이더넷 네트워크와 연결된다.
  - 통신 과정
    - 무선 LAN 액세스 포인트는 각 액세스 포인트들을 식별하는 SSID를 가지고 있고, 무선 LAN 클라이언트들이 식별할 수 있는 전파를 내뿜어서 인식할 수 있도록 한다.
    - 무선 LAN 액세스 포인트를 인식한 클라이언트가 해당 SSID로 접속 요청을 보내면 무선 LAN 액세스 포인트가 응답한다.
    - 클라이언트가 통신을 위해 무선 LAN 액세스 포인트에 전파를 날리면 통신이 이루어진다.
    - 여러 클라이언트가 통신을 위해 한꺼번에 전파를 날리면 충돌이 일어날 수 있기 때문에 CSMA/CA를 이용하여 충돌을 회피한다.

### 근거리에 있는 여러 대의 전자기기가 서로 통신하는 프로토콜은 어떻게 동작할까요?

- 이더넷
  - 브로드캐스트
    - 이더넷 프레임의 목적지 MAC 주소를 FFFFFFFF로 설정하여 전송하면 2계층 장비가 브로드캐스트로 인식하여 Flooding한다.
    - ARP와 같이 한 번에 여러 단말에게 프레임을 전송해야 할 때 사용된다.
  - 멀티캐스트
    - 16진수로 표시된 MAC 주소에서 0x01로 시작하는 MAC 주소는 모두 멀티캐스트로 작동한다.
    - IP 주소와 함께 사용될 경우 01005e로 시작하게 되고, 뒷 부분은 멀티캐스트 IP 주소의 뒷 부분 23비트를 16진수로 변환하여 사용한다.

### 아주 멀리 떨어져 있는 두 전자기기가 유선/무선으로 서로 통신하는 프로토콜은 어떻게 동작할까요?

- IP
  - 32비트로 이루어진 논리적인 주소인 IP 주소를 이용해서 외부망에 있는 전자기기와 통신하는 프로토콜이다.
  - 3계층 장비인 라우터를 통해 통신이 이루어진다. 라우터가 멀리 떨어진 전자기기까지 데이터를 전송할 수 있는 경로로 라우팅한다.
  - IP는 비신뢰성과 비연결성이 특징이다. 따라서 패킷을 보내도 중간에 유실될 수 있고, 데이터를 보낸 순서대로 도착할 것을 보장하지 않는다.

### 두 전자기기가 신뢰성을 가지고 통신할 수 있도록 하기 위한 프로토콜은 어떻게 동작할까요?

- TCP
  - 주로 IP와 같이 사용되는 IP 프로토콜의 상위 프로토콜이며, IP의 문제점인 비신뢰성을 해결한다.
  - Transmission Control Protocol이라는 이름에 걸맞게 데이터 전송을 제어하여 안정적인 전송을 보장하며, 데이터의 순서를 보장한다.
  - 안정적인 전송을 보장하기 위해 3 way handshake, 4 way handshake라는 작업을 하여 두 전자기기 간의 논리적인 연결을 확보한다.

### HTTP는 어떻게 동작할까요?

- HTTP
  - 웹에서 서로 정보를 주고받기 위해 사용되는 프로토콜이다.
  - TCP/IP를 기반으로 작동하는 프로토콜이며, 서버-클라이언트 구조로 되어 있다.
  - HTTP는 비연결성이 특징이기 때문에 클라이언트가 서버에 요청을 보내고 서버가 그에 맞는 응답을 보내면 연결을 끊는다. 따라서 클라이언트가 이후에 요청을 다시 보내면 서버는 해당 클라이언트를 기억하지 못한다.
  - TCP/IP를 기반으로 작동하기 때문에 3 way handshake를 통해 연결을 확보한 후에 클라이언트에서 요청, 서버에서 응답을 한 뒤에 연결을 끊는다.

## 우리가 브라우저의 주소 창에 www.knowre.com을 쳤을 때, 어떤 과정을 통해 서버의 IP 주소를 알게 될까요?

1. 로컬 DNS 서버에 URL을 요청하여 DNS 서버에 저장이 되어 있으면 IP 주소를 얻는다.
2. 로컬 DNS 서버에 없으면 Root DNS 서버에 요청을 보내고, Root DNS 서버는 URL의 Top-Level Domain(.com)을 확인하여 해당 Top-Level DNS 서버에 요청을 보내라고 한다.
3. .com DNS 서버에는 URL(www.knowre.com)에 대한 정보가 없으므로 Second-Level Domain(knowre.com)을 확인하여 knowre.com을 관리하는 DNS 서버에 요청을 보내라고 한다.
4. knowre.com DNS 서버는 www.knowre.com에 대한 IP 주소 정보를 가지고 있으므로 IP 주소를 응답받는다.

# Quest

## tracert(Windows가 아닌 경우 traceroute) 명령을 통해 www.google.com까지 가는 경로를 찾아보세요.

### 어떤 IP주소들이 있나요?

10.180.190.1

121.138.235.85

112.189.35.153

112.189.13.129

112.189.14.133

112.189.13.133

112.174.47.162

112.174.7.54

112.174.7.50

74.125.52.16

108.170.242.161

108.170.242.193

108.170.233.83

nrt13s51-in-f100.1e100.net (172.217.25.100)

### 그 IP주소들은 어디에 위치해 있나요?

성남 (ISP : KT)

미국 마운틴뷰 구글 플렉스 (ISP : Google)

## Wireshark를 통해 www.google.com으로 요청을 날렸을 때 어떤 TCP 패킷이 오가는지 확인해 보세요.

### TCP 패킷을 주고받는 과정은 어떻게 되나요?

1. 3-way handshake를 통해 클라이언트와 서버 간의 연결을 성립한다.
2. 클라이언트가 서버에 HTTP 요청을 보낸다.
3. 서버에서 클라이언트가 렌더링 해야할 HTML 텍스트를 여러 개로 분할하여 TCP 패킷에 담아 보낸다.
4. 서버에서 모든 데이터를 보냈으면 200 HTTP 응답을 보낸다.
5. 4-way handshake를 통해 클라이언트와 서버 간의 연결을 끊는다.

### 각각의 패킷에 어떤 정보들이 담겨 있나요?

1. Source Port : 송신자 포트
2. Destination Port : 수신자 포트
3. Sequence Number : 데이터 송신시 송신 데이터에 붙이는 고유번호. 3-way handshake를 할 때 랜덤으로 지정되며, 데이터를 전송할 때 이전 Sequence Number에 데이터의 크기만큼 더하여 전송한다. 데이터의 순서를 의미하기 때문에 수신자가 Sequence Number를 통해 분할된 데이터를 재조립한다.
4. Acknowledgement Number : 수신처에서 앞으로 받고자 하는 byte 순서 번호, 마지막으로 받은 데이터에 Sequence Number + 1하여 지정한다.
5. Flags
   1. SYN : 연결 요청 플래그
   2. ACK : 응답
   3. RST : 강제 종료
   4. PSH : 밀어 넣기
   5. URG : 긴급 데이터
   6. FIN : 연결 종료 요청
6. Window : 수신, 송신 가능한 버퍼 사이즈를 바이트 단위로 나타낸 값
7. Checksum : 패킷의 내용이 중간에서 변조되지 않았는지 확인하는 값
8. Urgent Pointer : URG 플래그가 on일때 참조하는 값으로, 데이터의 특정 부분을 먼저 보내달라고 요청하는 값.
9. Options : TCP 패킷의 옵션이다. 옵션없는 TCP 패킷이 20byte이며, 옵션이 최대로 붙으면 60byte가 된다.

## telnet 명령을 통해 http://www.google.com/ URL에 HTTP 요청을 날려 보세요.

### 어떤 헤더들이 있나요?

Date, Expires, Cache-Control, Content-Type, Server, X-XSS-Protection, X-Frame-Options, Set-Cookie, Accept-Ranges, Vary, Transfer-Encoding

### 그 헤더들은 어떤 역할을 하나요?

- Date : 패킷이 만들어진 날짜와 시간
- Expires : 응답 컨텐츠가 언제 만료되는지 나타냄.
- Cache-Control : 캐시를 허용할지 안 할지 정한다.
- Content-Type : body 데이터의 미디어 타입과 문자열 인코딩 지정
- Server : 요청을 처리하기 위한 오리진 서버의 소프트웨어 정보를 표시
- X-XSS-Protection : XSS 공격을 감지할 때 페이지 로드를 중지시키는 역할
- X-Frame-Options : 해당 페이지를 `<frame>`, `<iframe>`, 또는 `<object>` 에서 렌더링할 수 있는지 여부를 나타냄.
- Set-Cookie : 클라이언트에게 키=값 으로 되어있는 쿠키를 저장하라는 뜻
- Set-Cookie : 클라이언트에게 키=값 으로 되어있는 쿠키를 저장하라는 뜻
- Accept-Ranges : 부분 요청의 지원을 알리는 용도 (서버)
- Vary : 캐시된 응답을 향후 요청들에서 오리진 서버로 새로운 요청 헤더를 요청하는 대신 사용할 수 있는지 여부를 결정함.
- Transfer-Encoding : 사용자에게 엔티티를 안전하게 전송하기 위해 사용하는 인코딩 형식 지정

# Advanced

## HTTP의 최신 버전인 HTTP/3는 어떤 식으로 구성되어 있을까요?

UDP 기반의 프로토콜인 QUIC 프로토콜 사용하여 통신한다. 즉, 기존의 HTTP 버전들과 다르게 TCP 대신 UDP를 기반으로 동작한다.

- 기존 HTTP 버전들의 문제점
  - HTTP/1
    - 하나의 HTTP 요청마다 각각 핸드쉐이크 과정을 거쳤기 때문에 비효율이 발생했다.
  - HTTP/2
    - 단일 TCP 연결을 유지하면서 여러 요청을 처리할 수 있도록 변경되었다.
    - 핸드쉐이크의 횟수는 줄였지만, 핸드쉐이크 과정 자체는 건드리지 못했다.
  - HOLB (Head Of Line Blocking) -> TCP의 문제점
    - 패킷이 중간에 유실되거나 수신측의 패킷 파싱 속도가 느릴 때 통신에 병목이 발생하는 현상.
- HTTP/3의 해결방안
  - UDP를 채택하여 기존의 핸드쉐이크 과정을 날려버리고, 다른 방법으로 연결의 신뢰성을 확보하였다.
- UDP 채택 이유
  - QUIC은 TCP의 핸드쉐이크 과정을 최적하기 위해 구상된 프로토콜이다. UDP는 송신자 포트와 수신자 포트 정보 외에는 별다른 정보를 가지고 있지 않기 때문에 프로토콜 자체는 아무런 기능도 하지 않는다. UDP는 백지와 같은 프로토콜이기 때문에 TCP에 비해 훨씬 커스터마이징이 용이하다.
- HTTP/3의 개선점
  - 연결 설정 시 Latency 감소
  - 패킷 손실 감지에 걸리는 시간 단축
  - 멀티플렉싱 지원
  - 클라이언트의 ip가 바뀌어도 연결이 지속된다

## TCP/IP 외에 전세계적인 네트워크를 구성하기 위한 다른 방식도 제안된 바 있을까요?

- 타키온 프로토콜
  - 블록체인을 기반으로 한 탈중앙화 인터넷 프로토콜
  - 분산해시테이블, 블록체인, UDP, 암호화 등의 기술을 접목시켜 보안성이 높고 추적이 불가능하며 빠른 속도를 지닌 차세대 TCP/IP 구축을 목표로 한다.